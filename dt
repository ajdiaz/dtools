#! /bin/bash
# Distributed Tools - dtools - dt
# Copyright (C) 2008 Andrés J. Díaz <ajdiaz@connectical.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

${DEBUG:+set -x}
DTOOLS_LIB="${DTOOLS_LIB:-/usr/lib/dtools}"
LC_ALL=C; LANG=C; export LANG LC_ALL
SSH_OPTS="${SSH_OPTS:--q}"

# Some usefull functions to everybody, declared here to be accesible for all
# script and modules. We keep here check functions and error dispatchers.
err () { echo "${R}fail${N}::$(basename $0):$@" >&2  &&  ${E:+exit $E}; }
req () { type -p "$1" 2>/dev/null >/dev/null; }
lib () { source "${DTOOLS_LIB}/$1" 2>/dev/null >/dev/null; }
fun () { declare -F "$1" 2>/dev/null >/dev/null; }
cap () { tput "$1" 2>/dev/null >/dev/null; }
ssh () { command ssh -oUserKnownHostsFile="${dt_lst}" ${SSH_OPTS} "$@"; }
try () { "$@"; }

# Set the help string message which will be appear when we will call the
# script using the -h option in command line. Check parsing options block
# below for more information about internals.
str_help="usage:
  $0 [options] <pattern> <command> [arguments]+

patterns:
  exp:X    use regular expression X to match involving hosts.
  tag:X    match hosts with tag operation X (RTFM).
  all      an alias to exp:.*, affect to all registered hosts.

options:
  -h X   display this help about X command or this help screen.
  -H X   use X as known_hosts database.
  -p     pretend only and do nothing.
  -T X   use X threads (really use fork).
  -i     interactive, an alias to -T 0
  -N     supress color output
"
show_help () {
	if [ "$1" ] ; then
		lib "$1.bash" || E=1 err $"invalid command or internal command error"
	fi
	echo "$str_help"
	show_cmds
}
show_cmds () {
	echo "commands:"
	for file in ${DTOOLS_LIB}/*.bash; do
		source "$file" 2>/dev/null >/dev/null
		local file="$(basename $file)"
		local file="${file%.bash}"
		printf "  %-10s%s\n" "$file" "$str_sort"
	done
	echo
}
help () {
	if [ "$2" ] ; then
		str_help="$2"
		str_sort="$1"
	else
		str_help="$1"
	fi
}

# Parsing command line options in first place, this will be in the first
# argument, because module arguments can contains also options in the same
# format, so getopts it not usefull here.
while [[ "$1" == -* ]]; do
	case "$1" in
		-)  opt__=true ;;
		-h) show_help "$2" && exit 0 ;;
		-p) opt_p=true ;;
		-H) opt_H="$2" ; shift ;;
		-T) opt_T="$2" ; shift ;;
		-i) opt_T=0    ;;
		-N) opt_N=false;;
		-*) E=2 err $"unknown option $1"
	esac
	shift
done

# Fix progname to expand to command name.
cmd="$(basename $0)"
case "$cmd" in
	dt)	;;
	dt*)
		exp=$1 ; shift
		set -- "$1" "${cmd#dt}" "$@"
	;;
	*);;
esac
[ $# -lt 2 ] && E=2 err $"missing arguments, almost two are required"

# Define colors if capability is present in tty and if -N option is no
# present in command line.
if cap colors && ${opt_N:-true}; then
	H=$'\e[0;1m'
	N=$'\e[0;0m'
	R=$'\e[31;1m'
	G=$'\e[32;1m'
fi

okay () { echo "${G}okay${N}::$dt:$1:${H}$2${N}:$3" ; }
fail () { echo "${R}fail${N}::$dt:$1:${H}$2${N}:$3" ; }
# Define some internals variables, including default module extensions,
# default known_host database file and so on.
dt="$(basename $0)"
dt_lst=${opt_H:-~/.ssh/dt.known_hosts}
dt_ptr="$1" ; shift
dt_cmd="$1" ; shift

# Ensure that known_hosts exists
if [ ! -d "${dt_lst}" ] ; then
	mkdir -p $(dirname "${dt_lst}")
	touch "${dt_lst}"
fi

# Here are defined evaluations functions for host pattern included in
# command line. We support for regular expressions (using exp:<regexp>), and
# tags defined in known_hosts (by the tag:<tagop> format).
#
# TODO in the future we can provide a module method to add new patterns,
# like sqlite:<sentence> or similar.
dt_evl ()
{
	case "$1" in
		exp:*) dt_evl_exp "${1#exp:}" ;;
		tag:*) dt_evl_tag "${1#tag:}" ;;
		all)   dt_evl_exp ".*" ;;
		*) echo "${1//,/ }"
	esac
}

dt_evl_exp ()
{
	local ret=''
	local aux=''

	ret=(
			$(egrep  "^$1[,]*$" <(cut -d' ' -f1 "${dt_lst}"))
			$(egrep  ",$1$"  <(cut -d' ' -f1 "${dt_lst}"))
		)

	echo "${ret[@]%%,*}"
}

dt_evl_tag ()
{
	local ret=''
	local exp="$1"
	local exp="${exp//-/ | grep -v  -e}"
	local exp="${exp//+/ | grep  -e }"
	local exp="${exp//,/ -e  }"
	local exp="${exp//\(/\$\(grep -e }"
	local exp="${exp//\)/"<<<\$tag ) "}"

	while read host ssh key tag; do
		eval grep -e $exp <<<"$tag" >/dev/null && ret="$ret ${host%%,*}"
	done < "${dt_lst}"

	echo "$ret"
}

# Load library according the command provided as argument, if library not
# found or there are some error, then abort.
lib "${dt_cmd}.bash" ||
	E=1 err $"invalid command or internal command error"

fun run ||
	E=1 err $"internal command error"

# Evaluate the host pattern calling evaluation functions described below to
# obtain an array of affected hosts.
hosts=( $(dt_evl "$dt_ptr") )

# if pretend is enabled then display hosts and exit successfully.
if ${opt_p:-false}; then
	for h in "${hosts[@]}" ; do
		okay "pretend:$dt_cmd" "${h}"
	done
	exit 0
fi

# Set and validate the threading options if it's present on command
# line. Really bash do not handle threads properly, so we use standard
# child proccess XXX be carefull with loadavg measurements when use
# dtools many times, the loadavg value in shortterm can be increased
# so much. TODO in the future search best way than fork() to run in
# parallell, maybe creating a threads builtin, or port to bill.
let dt_thr="${opt_T:-5}"
let dt_cnt=0

# Set the interactive variable properly.
[ $dt_thr -gt 0 ] || interactive=true

# In interactive mode set password prompt to external fd, to interactuate
# with some modules like sudo.
# XXX This is UNSECURE!!
if ${interactive:-false}; then
	exec 3>$(tty)

pass () { echo -n "Password ($1 in $2): " >&3
		  read -s pass
		  echo >&3
		  echo "${pass//\n/}"; }

fi


dt_run () {
	local h="$1" ; shift

	ret="$(run "${h}" "$@" 2>&1)" &&
		okay "$dt_cmd" "${h}" "${ret//$'\n'/\\n}" ||
		fail "$dt_cmd" "${h}" "${ret//$'\n'/\\n}"
}

dt_filter ()
{
	for h in "${hosts[@]}"; do
		echo "$h"
	done
}


xhosts=( $(dt_filter | sort | uniq ) )

# Set interactive mode if command required it.
if ${interactive:-false} ; then
	dt_thr=0
else
	SSH_OPTS="$SSH_OPTS -oBatchMode=yes"
fi

${opt__:-false} && set -- "$@" "$(cat)"

dt_wait ()
{
	okay "interrupt" "" "waiting for childs..."
	wait
}
trap dt_wait INT

for h in "${xhosts[@]}" ; do

	# Dispatch runner if no thread configuration found, this provide
	# a linear beahviour.
	if [ $dt_thr -eq 0 ]; then
		dt_run "${h}" "$@"
		continue
	fi

	if [ $dt_cnt -lt $dt_thr ]; then
		((dt_cnt++))
		dt_run "${h}" "$@" &
	else
		dt_run "${h}" "$@" &
		wait
		let dt_cnt=0
	fi
done #| show

wait


