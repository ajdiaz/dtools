#! /bin/bash
# Distributed Tools - dtools - dt
# Copyright (C) 2008 Andrés J. Díaz <ajdiaz@connectical.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

DTOOLS_LIB="${DTOOLS_LIB:-/usr/lib/dtools}"
LC_ALL=C; LANG=C; export LANG LC_ALL

# Some usefull functions to everybody, declared here to be accesible for all
# script and modules. We keep here check functions and error dispatchers.
err () { echo "${R}fail${N}::$(basename $0):$@" >&2  &&  ${E:+exit $E}; }
req () { type -p "$1" 2>/dev/null >/dev/null; }
lib () { source "${DTOOLS_LIB}/$1" 2>/dev/null >/dev/null; }
fun () { declare -F "$1" 2>/dev/null >/dev/null; }
cap () { tput "$1" 2>/dev/null >/dev/null; }

# Set the help string message which will be appear when we will call the
# script using the -h option in command line. Check parsing options block
# below for more information about internals.
str_help="usage:
  $0 [options] <pattern> <command> [arguments]+

patterns:
  exp:X    use regular expression X to match involving hosts.
  tag:X    match hosts with tag operation X (RTFM)

options:
  -h X   display this help about X or this help screen.
  -H X   use X as known_hosts database.
  -p     pretend only and do nothing.
  -T X   use X threads (really use fork).
  -N     supress color output

Andrés J. Díaz <ajdiaz@connectical.com>
"
show_help () {
	if [ "$1" ] ; then
		lib "$1.bash" || E=1 err $"invalid command or internal command error"
	fi
	echo "$str_help"
}
help () { str_help="$1"; }

# Parsing command line options in first place, this will be in the first
# argument, because module arguments can contains also options in the same
# format, so getopts it not usefull here.
while [[ "$1" == -* ]]; do
	case "$1" in
		-h) show_help "$2" && exit 0 ;;
		-p) opt_p=true ;;
		-H) opt_H="$2" ; shift ;;
		-T) opt_T="$2" ; shift ;;
		-N) opt_N=false;;
		-*) E=2 err $"unknown option $1"
	esac
	shift
done
[ $# -lt 2 ] && E=2 err $"missing arguments, almost two are required"

# Define colors if capability is present in tty and if -N option is no
# present in command line.
if cap colors && ${opt_N:-true}; then
	H=$'\e[0;1m'
	N=$'\e[0;0m'
	R=$'\e[31;1m'
	G=$'\e[32;1m'
fi

# Define some internals variables, including default module extensions,
# default known_host database file and so on.
dt_lst=${opt_H:-~/.ssh/known_hosts}
dt_ptr="$1" ; shift
dt_cmd="$1" ; shift

# Here are defined evaluations functions for host pattern included in
# command line. We support for regular expressions (using exp:<regexp>), and
# tags defined in known_hosts (by the tag:<tagop> format).
#
# TODO in the future we can provide a module method to add new patterns,
# like sqlite:<sentence> or similar.
dt_evl ()
{
	case "$1" in
		exp:*) dt_evl_exp "${1#exp:}" ;;
		tag:*) dt_evl_tag "${1#tag:}" ;;
		*) echo "${1//,/ }"
	esac
}

dt_evl_exp ()
{
	local ret=''

	ret="$(egrep -o "^$1[,]*[[:space:]]*" <(cut -d' ' -f1 "${dt_lst}"))" ||
	ret="$(egrep -o "^,$1$"  <(cut -d' ' -f1 "${dt_lst}"))"

	echo "${ret%%,*}"
}

dt_evl_tag ()
{
	local ret=''
	local exp=1

	# tags operations are not trivial to parse, please check the reference
	# manual for more information about tag expressions.
	IFS=','
	for tag in $1 ; do
		case "$tag" in
			+*) exp="$exp '|' '(' "\$tag" ':' '${tag#+}' ')'" ;;
			-*) exp="$exp '&' '(' '(' "\$tag" ':' '${tag#-}' ')' '!=' '1' ')'" ;;
			**) exp="$exp '&' '('  "\$tag" ':' '$tag' ')'" ;;
		esac
	done

	IFS=' '
	while read host ssh key tag; do
		tag="${tag#tag:}"
		[ "$tag" ] || continue
		if [ "$tag" ] && eval expr ${exp} > /dev/null ; then
			ret="$ret ${host%%,*}"
		fi
	done < "${dt_lst}"
	echo "${ret}"
	exit 0;
}

# Load library according the command provided as argument, if library not
# found or there are some error, then abort.
lib "${dt_cmd}.bash" ||
	E=1 err $"invalid command or internal command error"

fun run ||
	E=1 err $"internal command error"

# Evaluate the host pattern calling evaluation functions described below to
# obtain an array of affected hosts.
hosts=( $(dt_evl "$dt_ptr") )

# if pretend is enabled then display hosts and exit successfully.
if ${opt_p:-false}; then
	for h in "${hosts[@]}" ; do
		echo "${G}okay${N}::$(basename $0):pretend:$dt_cmd:${H}${h}${N}"
	done
	exit 0
fi

# Set and validate the threading options if it's present on command
# line. Really bash do not handle threads properly, so we use standard
# child proccess XXX be carefull with loadavg measurements when use
# dtools many times, the loadavg value in shortterm can be increased
# so much. TODO in the future search best way than fork() to run in
# parallell, maybe creating a threads builtin, or port to bill.
let dt_thr="${opt_T:-5}"
let dt_cnt=0

dt_run () {
	local h="$1" ; shift
	ret="$(run "${h}" "$@" 2>&1)" &&
		echo "${G}okay${N}::$(basename $0):$dt_cmd:${H}${h}${N}:${ret//$'\n'/\\n}" ||
		echo "${R}fail${N}::$(basename $0):$dt_cmd:${H}${h}${N}:${ret//$'\n'/\\n}"
}

for h in "${hosts[@]}" ; do

	# Dispatch runner if no thread configuration found, this provide
	# a linear beahviour.
	if [ $dt_thr -eq 0 ]; then
		dt_run "${h}" "$@"
		continue
	fi

	if [ $dt_cnt -lt $dt_thr ]; then
		((dt_cnt++))
		dt_run "${h}" "$@" &
	else
		wait
		let dt_cnt=0
	fi
done

wait
